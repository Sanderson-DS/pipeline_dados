Desafio: desenvolvendo um script
 Próxima Atividade

Até o momento temos desenvolvido nosso pipeline em um notebook Jupyter, que oferece um ambiente interativo e prático para o aprendizado e experimentação de novos conceitos e métodos. Agora, temos um novo desafio!

Nosso objetivo é ter um pipeline de dados eficiente e automatizado. Portanto, para nos aproximarmos ainda mais dessa realidade, nosso próximo desafio é transformar o código que desenvolvemos até agora no nosso notebook em um script Python estruturado em funções.

Essa abordagem traz vantagens como: facilidade de teste, reutilização de código, manutenção mais simples e automação do pipeline. Sem contar que, em um ambiente de produção, geralmente são utilizados scripts ao invés de notebooks. Então, bora desenvolver e praticar essa habilidade?

Orientações para o desafio
Preparando o ambiente:
crie uma subpasta chamada scripts na sua pasta de trabalho;
na pasta scripts crie um arquivo chamado "extract_and_save_data.py".
Desenvolvendo o código:
Para desenvolver as funções a seguir, você pode utilizar os códigos já feitos no notebook, adaptando-os para que se tornem funções, sendo elas:

1 - connect_mongo(uri): estabelece a conexão com a instância do MongoDB usando a URI fornecida. Ela retorna o cliente do MongoDB que permite interagir com o banco de dados.

2 - create_connect_db(client, db_name): utiliza o(a) cliente do MongoDB para criar (se não existir) e conectar-se ao banco de dados especificado pelo parâmetro db_name. Ela retorna o objeto de banco de dados que pode ser usado para interagir com as coleções dentro dele.

3 - create_connect_collection(db, col_name): cria (se não existir) e conecta-se à coleção especificada pelo parâmetro col_name dentro do banco de dados fornecido. Ela retorna o objeto de coleção que pode ser usado para interagir com os documentos dentro dela.

4 - extract_api_data(url): extrai dados de uma API na URL fornecida e retorna os dados extraídos no formato JSON.

5 - insert_data(col, data): recebe uma coleção e os dados que serão inseridos nela. Ela deve adicionar todos os documentos à coleção e retornar a quantidade de documentos inseridos.

Com as funções prontas, o próximo desafio é executá-las, realizando os seguintes passos:

criar um novo banco de dados;
criar uma coleção;
extrair os dados da API: https://labdados.com/produtos;
inserir os dados da API na coleção criada.
Se precisar de ajuda, na seção "Opinião da pessoa instrutora" você pode encontrar uma das formas de resolver o desafio proposto acima.

Ver opinião do instrutor
Opinião do instrutor


Bora resolver esse desafio?

Vale ressaltar que existem diferentes maneiras de fazer a mesma coisa utilizando a linguagem Python. Então, a solução abaixo não é a única forma de resolver o desafio proposto.

Código das funções
Nós podemos começar importando todas as bibliotecas que precisamos utilizar e em seguida construir as funções. Os códigos de cada função são basicamente os códigos que desenvolvemos no nosso notebook até o momento, a diferença é que estão adaptados de acordo com os parâmetros que cada função deve receber.

from pymongo.mongo_client import MongoClient
from pymongo.server_api import ServerApi
import requests

def connect_mongo(uri):
    # Criando um novo cliente e conectando ao servidor
    client = MongoClient(uri, server_api=ServerApi('1'))

    # Enviando um ping pra conferir se a conexão foi realizada
    try:
        client.admin.command('ping')
        print("Pinged your deployment. You successfully connected to MongoDB!")
    except Exception as e:
        print(e)

    return client

def create_connect_db(client, db_name):
    db = client[db_name]
    return db

def create_connect_collection(db, col_name):
    return db[col_name]

def extract_api_data(url):
    return requests.get(url).json()

def insert_data(col, data):
    result = col.insert_many(data)
    n_docs_inseridos = len(result.inserted_ids)
    return n_docs_inseridos 
Copiar código
Na função insert_data o trecho de código len(result.inserted_ids) retorna a quantidade de ids que foram inseridos na nossa base de dados, ou seja, a quantidade de documentos inseridos. Essa informação é importante para conseguirmos conferir se foram inseridos a quantidade de dados que esperávamos.

Executando as funções
Uma vez que as funções estão prontas, nós podemos executá-las para testar seu funcionamento. Para testá-las, vamos:

criar um banco de dados chamado "db_produtos_desafio";
criar uma coleção com o nome "produtos";
extrair os dados da API e adicioná-los à nossa coleção.
O código a seguir foi desenvolvido no mesmo script de criação das funções:

if __name__ == "__main__":
    
    client = connect_mongo("mongodb+srv://millenagena:12345@cluster-pipeline.bsouxli.mongodb.net/?retryWrites=true&w=majority")
    db = create_connect_db(client, "db_produtos_desafio")
    col = create_connect_collection(db, "produtos")

    data = extract_api_data("https://labdados.com/produtos")
    print(f"\nQuantidade de dados extraidos: {len(data)}")

    n_docs = insert_data(col, data)
    print(f"\nDocumentos inseridos na colecao: {n_docs}")

    client.close()
Copiar código
Entendendo o if __name__ == "__main__":
O if __name__ == "__main__": é um código comum em Python e sua principal utilização é permitir ou impedir partes do código de serem executadas quando os módulos (scripts) são importados.

Quando um módulo Python é importado, o Python define uma variável especial __name__ para esse módulo. Para o módulo que está sendo executado diretamente, o __name__ será sempre __main__. No entanto, para os que são importados, a variável __name__ será o nome do módulo.

Assim, ao usar if __name__ == "__main__":, estamos essencialmente dizendo: "Execute este bloco de código apenas se este arquivo estiver sendo executado diretamente e não se ele estiver sendo importado por outro script."

Isso permite que a gente tenha partes do código (geralmente testes ou exemplos) que podem ser executadas quando o arquivo é executado diretamente, mas que não serão executadas quando o arquivo é importado como módulo. Isso pode ser útil em situações em que você deseja usar suas funções em outro script, porém não quer que o código de teste seja executado nesse momento.

Lembre de praticar para fixar todos os conteúdos aprendidos, viu? Qualquer dúvida, sinta-se à vontade para compartilhar no fórum ou na nossa comunidade no Discord.
